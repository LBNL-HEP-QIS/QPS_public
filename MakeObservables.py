import math
import numpy as np

'''
Important note on this file:

An 'event list' is represented as a list of N + n_I strings, where each string represents a particle -- 
corresponding to the n_I initial particles and N simulation steps.

The possible symbols for the particles arethe strings: f1, af1, f2, af2, phi, and 0.

Note: the event list is read from right to left -- initial particles occupy indices -1 .. -n_I,
      index -(n_I+1) represents the particle emitted during the first simulation step, while
      index 0 represents the particle emitted during the last simulation step.

For example, an event might look like ['0', '0', '0', 'f1'] if there is a fermion that does not radiate at all. 
Another example is ['0', 'phi', '0', 'f1'] in which a fermion radiates a phi in the second step.
A third example is ['af2', 'f2', '0', 'f1'] in which a fermion radiates a phi in the second step, 
                                       which then splits into an f2-af2 pair in the third step.
'''


def Nemissions(myevent, n_I= 1):
    '''
    Computes the number of emissions from an event list.

    Params:
        myevent (List(str)) A list that describes the emission history. See the top of this file.
        n_I     (int)       number of initial particles in myevent
    '''
    mycount = 0
    for i in range(0, len(myevent) - n_I):
        if myevent[i]!= '0':
            mycount+= 1
            pass
        pass
    return mycount


def LogThetaMax(myevent, n_I= 1, eps= 0.001):
    '''
    Computes the hardest emission (θmax) from an event list.

    Params:
        myevent (List(str)) A list that describes the emission history. See the top of this file.
        n_I     (int)       number of initial particles in myevent
        eps     (float)     See Section IV, Eq. (17).

    Returns:
        Tuple: (float, Array, Array) = (firstemmit, centers, hist_bins), where

        firstemmit (float)       = location of the hardest emission (note: guaranteed to be an element in centers)
        centers   (Array(float)) = centers of bins generated by discretizing the scale parameter
        hist_bins (Array(float)) = edges of bins generated by discretizing the scale parameter

    If there is no emission, the first output is None.
    '''
    N = len(myevent) - n_I
    firstemmit = -1
    for i in reversed(range(0, len(myevent) - n_I)):
        if myevent[i]!= '0':
            firstemmit= len(myevent) - n_I - i - 1
            break

    hist_bins = [math.log(eps**(j / N)) for j in range(N, -1, -1)]
    hist_bins = np.array(hist_bins)
    centers = (hist_bins[:-1] + hist_bins[1:]) / 2.

    if firstemmit != -1:
        return centers[::-1][firstemmit], centers, hist_bins
    else:
        return None, centers, hist_bins


def hist_bins(N, eps):
    '''
    Computes the hardest emission (θmax) from an event list.

    Params:
        N   (int)   Number of steps in the simulation.
        eps (float) See Section IV, Eq. (17).

    Returns:
        Tuple: (Array, Array) = (hb, centers), where

        hb      (Array(float)) = edges of bins generated by discretizing the scale parameter
        centers (Array(float)) = centers of bins generated by discretizing the scale parameter
    '''
    hb = [math.log(eps**(j / N)) for j in range(N, -1, -1)]
    hb = np.array(hb)
    centers = (hb[:-1] + hb[1:]) / 2.

    return hb, centers